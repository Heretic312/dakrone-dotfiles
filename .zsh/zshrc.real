### vim:ft=zsh:foldmethod=marker
###
### This is the real setup file.
### All magic starts here.
###
### Frank Terbeck <ft@bewatermyfriend.org>
### Last-Modified: Wed Feb 25 13:50:26 2009
###
### URI: <http://ft.bewatermyfriend.org/comp/zsh.html>
###

## functions for (mostly) internal use
### zprintf()           our printing service #{{{
function zprintf() {
    local -i level; local format
    level=$1 ; format=$2; shift; shift

    (( ZSHRC_VERBOSE < level )) && return 0

    printf '[%2d] '${format} ${level} "$@"
}
### }}}
### zrcsource()         $ZRCS[] builder {{{
###   + handles files that shouldn't give errors if they don't exist
function zrcsource() {
    setopt local_options
    ### Note that zsh version 3.0.5 and earlier needs extendedglob
    ### to be switched on to make '~/...' expansions work in ZRCSOURCE_DIR.
    ### This does not hurt in newer versions, so I'll set this here.
    setopt extended_glob
    local file
    file="${ZRC_SOURCE_DIR}/${1}"
    if [[ -r ${~file} ]] ; then
        ZRCS=( ${ZRCS} ${~file} )
    elif [[ -z ${2} ]] ; then
        ZRCS=( ${ZRCS} ${~file} )
    else
        zprintf 1 'zshrc: ignoring non-existant file: %s\n' ${~file}
    fi
} #}}}
### zdepend()           calculate order of files to source {{{
###
### Okay, this is overkill. But this config got too big a long time ago.
### So, who cares? :-)
### Anyway: Since this config is split into various files, some files
### depend on others to be sourced already. Because of that, I introduced
### the possibility of every file added to $ZRCS[] via zrcsource() to start
### with '#zdep ...' in the 1st line (where ... is a comma seperated list of
### files that file requires to be loaded already).
###
### To cut a long story short: zdepend() resorts $ZRCS[] to reflect the
### information found in the #zdep lines.
function zdepend() {
    # be verbose if $ZSHRC_VERBOSE >= 5
    setopt localoptions extendedglob
    local zdepdebug=0
    (( zdepdebug == 1 )) && set -x
    local added=1 untagged=0 satisfied subsat
    local sortedRCS ; sortedRCS=()
    local file buf tmp tag istag dep deplist sorted
    local deps tags ; deps=() ; tags=( __all__ __begin__ __end__ )

    ### read the #zdep lines {{{
    ### yes, this is insane. :-) - But I want to know if it's doable.
    for file in ${ZRCS} ; do
        read buf < $file
        if [[ ${buf} !=  '#zdep '* ]] ; then
            ### files names 'zshrc.local' are always tagged __end__, if the #zdep line is missing.
            if [[ ${file} == *'/zshrc.local' ]] ; then
                deps=(${deps} "${file}:__end__")
            else
                deps=(${deps} "${file}:")
            fi
            continue
        fi
        buf="${buf#\#zdep }"
        tmp=(${(s:,:)buf})
        if [[ -n ${tmp[1]} ]] ; then
            istag=0
            for tag in ${tags} ; do
                if [[ ${tag} == ${tmp[1]} ]] ; then
                    istag=1
                    break
                fi
            done
            if (( istag > 0 )) ; then
                deps=(${deps} "${file}:${tmp[1]}")
                continue
            fi
            buf="${ZRC_SOURCE_DIR}/${tmp[1]}"
            shift tmp
        else
            buf=""
        fi
        for i in ${tmp} ; do
            for tag in ${tags} ; do
                if [[ ${tag} == ${i} ]] ; then
                    istag=1
                    break
                fi
            done
            if (( istag > 0 )) ; then
                deps=(${deps} "${file}:${i}")
                break
            fi
            buf="${buf},${ZRC_SOURCE_DIR}/${i}"
        done
        tmp=""
        deps=(${deps} "${file}:${buf#\#zdep }")
    done
    ### }}}
    for file in ${deps} ; do [[ ${file} != *:__*__ ]] && untagged=$((untagged + 1)) ; done
    for file in ${deps} ; do [[ ${file} == *:__begin__ ]] && sortedRCS=(${sortedRCS} ${file%:*}) ; done
    untagged=$((untagged + ${#sortedRCS}))
    ### resolve dependencies {{{
    ### okay, reading the '#zdep' lines wasn't too cheap. Yet, this
    ### loop is really expensive. But since it only handles a few strings,
    ### I'll do it. :-)
    while true ; do
        if (( added > 0 )) ; then
            added=0
        else
            zprintf 0 "zdepend(): Dependency problems. Giving up.\n"
            print -l ${sortedRCS}
            return 1
        fi
        for tmp in ${deps} ; do
            file=${tmp%:*} ; deplist=${tmp#*:} ; satisfied=1
            for sorted in ${sortedRCS} ; do [[ ${sorted} == ${file} ]] && continue 2 ; done
            for dep in ${(s:,:)deplist} ; do
                for sorted in ${sortedRCS} ; do
                    subsat=0
                    : HERE_BABY
                    [[ ${sorted} == ${~dep} ]] && subsat=1 && break
                done
                    (( subsat == 0 )) && satisfied=0 && break
            done
            (( satisfied > 0 )) && sortedRCS=(${sortedRCS} ${file%:*}) && added=$((added + 1))
        done
        (( ${#sortedRCS} >= untagged )) && break
    done
    ### }}}
    for file in ${deps} ; do [[ ${file} == *:__all__   ]] && sortedRCS=(${sortedRCS} ${file%:*}) ; done
    for file in ${deps} ; do [[ ${file} == *:__end__   ]] && sortedRCS=(${sortedRCS} ${file%:*}) ; done
    (( zdepdebug == 1 )) && set +x
    zprintf 5 'zshrc source order:\n'
    for tmp in ${sortedRCS} ; do
        zprintf 5 '    + %s\n' ${tmp}
    done
    ZRCS=(${sortedRCS})
    return 0
} #}}}
### is_*()              quick version checks {{{

### this VERSION_* array solution could be more elegant,
### but zsh versions prior to 3.1.6 do not support associative arrays.
### so, to stay backwards compatible we do not use them here.
VERSION_TABLE=( #{{{
    "3.0.6" "3.1.3" "3.1.4" "3.1.6" "3.1.7"
    "4.0.2" "4.2.1" "4.2.2"
    "3.0"   "3.1"   "4.0"   "4.1"
    "4.2"   "4.3"   "4.3.1" "4.3.2" "4.3.3" "4.3.5" "4.3.7" "4.3.8" "4.3.9"
)
#}}}
VERSION_SHORT=( #{{{
    "306" "313" "314" "316" "317"
    "402" "421" "422"
    "30"  "31"  "40"  "41"
    "42"  "43"  "431" "432" "433" "435" "437" "438" "439"
)
#}}}
VERSION_CHECKS_ATLEAST=( #{{{
    '${ZSH_VERSION} == 3.0.<6->* || ${ZSH_VERSION} == 3.<1->.<->* || ${ZSH_VERSION} == <4->.<->*'
    '${ZSH_VERSION} == 3.1.<3->* || ${ZSH_VERSION} == 3.<2->.<->* || ${ZSH_VERSION} == <4->.<->*'
    '${ZSH_VERSION} == 3.1.<4->* || ${ZSH_VERSION} == 3.<2->.<->* || ${ZSH_VERSION} == <4->.<->*'
    '${ZSH_VERSION} == 3.1.<6->* || ${ZSH_VERSION} == 3.<2->.<->* || ${ZSH_VERSION} == <4->.<->*'
    '${ZSH_VERSION} == 3.1.<7->* || ${ZSH_VERSION} == 3.<2->.<->* || ${ZSH_VERSION} == <4->.<->*'
    '${ZSH_VERSION} == 4.0.<2->* || ${ZSH_VERSION} == 4.<1->.<->* || ${ZSH_VERSION} == <5->.<->*'
    '${ZSH_VERSION} == 4.2.<1->* || ${ZSH_VERSION} == 4.<3->.<->* || ${ZSH_VERSION} == <5->.<->*'
    '${ZSH_VERSION} == 4.2.<2->* || ${ZSH_VERSION} == 4.<3->.<->* || ${ZSH_VERSION} == <5->.<->*'
    '${ZSH_VERSION} == <3->.<->*'
    '${ZSH_VERSION} == 3.<1->.<->* || ${ZSH_VERSION} == <4->.<->*'
    '${ZSH_VERSION} == <4->.<->*'
    '${ZSH_VERSION} == 4.<1->.<->* || ${ZSH_VERSION} == <5->.<->*'
    '${ZSH_VERSION} == 4.<2->.<->* || ${ZSH_VERSION} == <5->.<->*'
    '${ZSH_VERSION} == 4.<3->.<->* || ${ZSH_VERSION} == <5->.<->*'
    '${ZSH_VERSION} == 4.3.<1->* || ${ZSH_VERSION} == 4.<4->.<->* || ${ZSH_VERSION} == <5->.<->*'
    '${ZSH_VERSION} == 4.3.<2->* || ${ZSH_VERSION} == 4.<4->.<->* || ${ZSH_VERSION} == <5->.<->*'
    '${ZSH_VERSION} == 4.3.<3->* || ${ZSH_VERSION} == 4.<4->.<->* || ${ZSH_VERSION} == <5->.<->*'
    '${ZSH_VERSION} == 4.3.<5->* || ${ZSH_VERSION} == 4.<4->.<->* || ${ZSH_VERSION} == <5->.<->*'
    '${ZSH_VERSION} == 4.3.<7->* || ${ZSH_VERSION} == 4.<4->.<->* || ${ZSH_VERSION} == <5->.<->*'
    '${ZSH_VERSION} == 4.3.<8->* || ${ZSH_VERSION} == 4.<4->.<->* || ${ZSH_VERSION} == <5->.<->*'
    '${ZSH_VERSION} == 4.3.<9->* || ${ZSH_VERSION} == 4.<4->.<->* || ${ZSH_VERSION} == <5->.<->*'
)
#}}}
VERSION_CHECKS=( #{{{
    '${ZSH_VERSION} == 3.0.6' '${ZSH_VERSION} == 3.1.3' '${ZSH_VERSION} == 3.1.4' '${ZSH_VERSION} == 3.1.6'
    '${ZSH_VERSION} == 3.1.7' '${ZSH_VERSION} == 4.0.2' '${ZSH_VERSION} == 4.2.1'
    '${ZSH_VERSION} == 4.2.2'
    '${ZSH_VERSION} == 3.0.*' '${ZSH_VERSION} == 3.1.*' '${ZSH_VERSION} == 4.0.*'
    '${ZSH_VERSION} == 4.1.*' '${ZSH_VERSION} == 4.2.*' '${ZSH_VERSION} == 4.3.*'
    '${ZSH_VERSION} == 4.3.1'
    '${ZSH_VERSION} == 4.3.2' '${ZSH_VERSION} == 4.3.3' '${ZSH_VERSION} == 4.3.5' '${ZSH_VERSION} == 4.3.7'
    '${ZSH_VERSION} == 4.3.8' '${ZSH_VERSION} == 4.3.9'

)
#}}}

### generating zis_*()
### {{{

if [[ ${#VERSION_TABLE} != ${#VERSION_CHECKS_ATLEAST}
   || ${#VERSION_TABLE} != ${#VERSION_SHORT}
   || ${#VERSION_TABLE} != ${#VERSION_CHECKS}         ]] ; then

    zprintf 0 'Automatic zis_*() generation failed! Using fallback. Please check.\n'
    for i in {1..${#VERSION_TABLE}} ;do
        eval "function zis_${VERSION_SHORT[$i]}() { return 0 }"
    done
else
    for i in {1..${#VERSION_TABLE}} ; do

        eval "function zis_${VERSION_SHORT[$i]}() { \
setopt localoptions noxtrace ; \
if [[ \${1} == \"atleast\" ]] ; then [[ ${VERSION_CHECKS_ATLEAST[$i]} ]] && return 0 ; \
else [[ ${VERSION_CHECKS[$i]} ]] && return 0 ; fi ; \
zprintf 4 \"  + zis_${VERSION_SHORT[$i]}: this is not %s (%s)\\n\" ${VERSION_TABLE[$i]} ${ZSH_VERSION}; \
return 1 }"

    done
fi

### }}}
### }}}
### zrcautoload()       wrapper for autoload {{{
function zrcautoload() {
    setopt local_options
    setopt extended_glob
    local fdir ffile
    local -i ffound
    ffile=${1}
    (( found = 0 ))
    for fdir in ${fpath} ; do
        [[ -e ${fdir}/${ffile} ]] && (( ffound = 1 )) && break
    done
    if (( ffound == 0 )) ; then
        zprintf 2 "  zrcautoload: cannot find %s\n" ${ffile}
        return 1
    fi
    zprintf 3 "  zrcautoload: loading %s\n" ${ffile}
    if zis_316 "atleast" ; then
        autoload -U ${ffile} || return 1
    else
        autoload ${ffile}    || return 1
    fi
    return 0
}
#}}}
### zrcbindkey()        wrapper for bindkey and $key[] {{{
# Let's document this a little, since it's become non-trivial:
#
# zrcbindkey [-W|-M <m-arg>|-s] keysym action
#
# The M and s options are passed to the bindkey builtin. See its documentation
# for details. The -W option is handled by the wrapper. When used, zrcbindkey
# checks whether the widget in question is available before trying to bind the
# key(-combination). If the widget could not be found, the wrapper returns 2.
#
# The keysym arg can be a combination of one or two entries from the $key hash.
# To list these, use zrclistkeys().
#
# Examples: Ctrl-x-f, Ctrl-x-Ctrl-f, Alt-Enter, PageUp
function zrcbindkey() {

    zis_317 "atleast" || return 3

    setopt localoptions extendedglob noksharrays #xtrace
    local -i check
    local keysym sym2 wid
    local -a keysyms opts wopt

    zparseopts -E 'M:=opts' 's=opts'
    zparseopts -E -D 'W=wopt'
    (( ${#wopt} )) && (( check = 1 ))

    keysyms=()
    keysym=${argv[-2]}
    [[ ${keysym} == (#b)(Ctrl-?|Alt-)-(*) ]] && \
        keysyms=(${match})

    wid=${argv[-1]}

    if (( check > 0 )) ; then
        [[ -z ${widgets[$wid]} ]] && return 2
    fi

    if [[ -n ${keysyms[1]} ]] || [[ -n ${key[$keysym]} ]] ; then
        if (( ${#keysyms} > 0 )) then
            [[ -n ${key[${keysyms[2]}]} ]] && \
                sym2=${key[${keysyms[2]}]} || \
                sym2=${keysyms[2]}

            builtin bindkey ${opts} ${key[${keysyms[1]}]}${sym2} ${wid}
            return $?
        fi
        builtin bindkey ${opts} ${key[$keysym]} ${wid}
        return $?
    fi

    if (( check > 0 )) ; then
        builtin bindkey "${@}"
        return $?
    fi

    return 1
}
# }}}
### zrclistkeys()       show keysyms-strings for zrcbindkey() {{{
function zrclistkeys() {
    for i in ${(kon)key}; do
        printf '%s: '\''%s'\''\n' ${i} ${(q)${key[$i]}}
    done
}
# }}}
### zrcmodload()        wrapper for zmodload (tests ${module_path}) {{{
function zrcmodload() {
    zis_313 "atleast" || return 4
    local opts mod matches good

    opts=() ; (( good = 0 ))
    while [[ $1 == -* ]] ; do
        opts=( ${opts} $1 )
        shift
    done
    mod=${1}
    shift

    if [[ ${modules[$mod]} == 'loaded' ]] ; then
        zprintf 3 "   zrcmodload: already loaded: %s - Skipping.\n" ${mod}
        return 0
    fi

    if [[ ${mod} == zsh/* ]] || [[ ${mod} == 'compctl' ]] ; then
        (( good = 1 ))
    fi

    if (( good == 0 )) ; then
        zprintf 0 'Failed to handle call: zrcmodload %s %s %s\n' "${opts}" "${mod}" "${(j: :)@}"
        return 3
    fi

    matches=( ${^module_path}/${mod}.so(N) )
    (( ${#matches} == 0 )) && return 2

    zprintf 3 "   zrcmodload: loading %s\n" ${mod}
    zmodload "${opts[@]}" ${mod} "$@"
    return $?
}
# }}}
### zrcneedcomp()       check if rc needs recompilation {{{
function zrcneedcomp() {
    local recomp
    local rc=${1:t}
    if [[ -z ${1} ]] ; then
        zprintf 0 "usage: ${0} <rcfile>\n"
        return 0
    fi
    if ! zis_317 "atleast" ; then
        zprintf 4 "  zrcneedcomp(): rccompilation needs at least zsh v3.1.7\n"
        return 0
    fi

    if [[ ! -e ${1}.zwc ]] ; then
        zprintf 3 "  zrcneedcomp(): ${rc}.zwc does not exist,\n    - marking for compilation.\n"
        return 1
    fi
    if [[ ${1} -nt ${1}.zwc ]] ; then
        zprintf 3 "  zrcneedcomp(): ${rc} is newer than ${rc}.zwc,\n"
        recomp=1
    elif ! zcompile -t ${1}.zwc >/dev/null 2>&1 ; then
        zprintf 3 "  zrcneedcomp(): ${rc}.zwc is compiled for different zsh version,\n"
        recomp=1
    fi
    if (( recomp > 0 )) ; then
        zprintf 3 "    - marking for recompilation.\n"
        return 2
    fi
    return 0
}
#}}}
### salias()            smart creation of sudo aliases {{{
### This is based on the salias() function I did for the grml zshrc.
### However, I changed it again to work with older versions of zsh as well.
### Added -c option. Added -C option.
### Note, that this has _nothing_ to do with suffix aliases.

function salias() {
    local only=0 multi=0 check=0 chkcom=1 sudo_host=0
    local sudo_u sudo_us sudo_h i j key val mval
    if (( ${#argv} == 0 )) ; then
        printf 'salias(): Missing argument. Try salias -h for help.\n'
        return 1
    fi
    while [[ ${1} == -* ]] ; do
        case ${1} in
            (-o) only=1  ;;
            (-C) chkcom=0 ;;
            (-c) check=1 ;;
            (-a) multi=1 ;;
            (--) shift ; break ;;
            (-h)
                printf 'usage: salias [-h|-o|-a|-c|-C] <alias-expression>\n'
                printf '  -h      shows this help text.\n'
                printf '  -a      replace '\'' ; '\'' sequences with '\'' ; sudo '\''.\n'
                printf '          be careful using this option.\n'
                printf '  -o      only sets an alias if a preceding sudo would be needed.\n'
                printf '  -c      check $sudo_hosts[] array.\n'
                printf '  -C      don'\''t check if the command in the alias exists.\n'
                printf '          Use this if the command requires a special check, that.\n'
                printf '          check_com() cannot deal with.\n'
                return 0
                ;;
            (*) printf "unkown option: '%s'\n" "${1}" ; return 1 ;;
        esac
        shift
    done
    if (( check > 0 )) ; then #{{{
        for i in ${sudo_hosts} ; do
            sudo_u=${${(s:@:)i}[1]}
            sudo_us=(${(s:,:)sudo_u})
            sudo_h=${${(s:@:)i}[2]}
            if [[ ${sudo_h} == ${HOST} ]] ; then
                for j in ${sudo_us} ; do
                    if [[ ${USER:-${LOGNAME}} == ${j} ]] ; then
                        ### user and host matches, okay.
                        sudo_host=1
                        break;
                    fi
                done
                break;
            fi
        done
        (( sudo_host == 0 )) && return 0
    fi #}}}
    if (( ${#argv} > 1 )) ; then
        printf 'Too many arguments %s\n' "${#argv}"
        return 1
    fi
    ### create the alias {{{
    key="${1%%\=*}" ;  val="${1#*\=}"
    if (( EUID == 0 )) && (( only == 0 )); then
        if (( chkcom > 0 )) ; then
            check_com ${val} || return 0
        fi
        alias -- "${key}=${val}"
    elif (( EUID > 0 )) ; then
        if (( multi > 0 )) ; then
            mval=(${(s, ; ,)val})
            if (( chkcom > 0 )) ; then
                check_com ${mval[1]} || return 0
            fi
            val="sudo ${mval[1]}"
            shift mval
            for i in ${mval} ; do
                if (( chkcom > 0 )) ; then
                    check_com ${i} || return 0
                fi
                val="${val} ; sudo ${i}"
            done
            alias -- "${key}=${val}"
        else
            if (( chkcom > 0 )) ; then
                check_com ${val} || return 0
            fi
            alias -- "${key}=sudo ${val}"
        fi
    fi
    ### }}}
    return 0
}
### }}}
### xalias()            check for executable, then create alias {{{
### only supposed to be used with simple aliases.
function xalias() {
    local key val com
    if (( ${#argv} == 0 )) ; then
        printf 'xalias(): Missing argument.\n'
        return 1
    fi
    if (( ${#argv} > 1 )) ; then
        printf 'xalias(): Too many arguments %s\n' "${#argv}"
        return 1
    fi

    key="${1%%\=*}" ;  val="${1#*\=}"
    check_com ${val} && alias -- "${key}=${val}"
    return 0
}
### }}}
### xhashd()            check for directory, then create hash -d {{{
function xhashd() {
    local key val com
    if (( ${#argv} == 0 )) ; then
        printf 'xhashd(): Missing argument.\n'
        return 1
    fi
    if (( ${#argv} > 1 )) ; then
        printf 'xhashd(): Too many arguments %s\n' "${#argv}"
        return 1
    fi

    key="${1%%\=*}" ;  val="${1#*\=}"
    [[ -d ${val} ]] && hash -d -- "${key}=${val}"
    return 0
}
### }}}
### check_com()         check if a command exists {{{
### eg: check_com "vim -p"
function check_com() {
    local val ; local com

    if [[ ${1} == '-c' ]] ; then
        shift
        [[ -n ${commands[$1]} ]] && [[ -x ${commands[$1]} ]] && return 0
        return 1
    fi

    val=${1}
    if zis_317 "atleast" ; then
        com=(${(z)val})
    else
        ### <3.1.7 does not know (z); this makes things less flexible. Oh well...
        com=(${(s: :)val})
    fi

    [[ -x $(whence -p ${com[1]}) ]] && return 0
    return 1
}
### }}}
### check_com_print()   check_com() + error msg {{{
function check_com_print() {
    local command=$1

    if ! check_com ${command} ; then
        printf '%s not found in $path.\n' ${command}
        return 1
    fi
    return 0
}
### }}}

if ! zis_317 "atleast" ; then
    function zstyle() { }
fi

zprintf 1 'Starting zsh v%s\n' ${ZSH_VERSION}
ZRCS=()

### warm greeting to those living in stone age ;)
### {{{
if ! zis_40 "atleast" ; then
    printf "\n"
    printf "  +----------------------------------------------------------------------\n"
    printf "  |\n"
    printf "  |  Howdy stone-ager!\n"
    printf "  |\n"
    printf "  |    You are running version %s of zsh.\n" ${ZSH_VERSION}
    printf "  |    That is quite old.\n"
    printf "  |\n"
    printf "  |    You should consider updating to at least v4.0\n"
    printf "  |    If that is not up to you, bug your admin until he does. ;)\n"
    printf "  |    The newer versions do really have nice features\n"
    printf "  |    that these fossils do not.\n"
    printf "  |\n"
    printf "  |    The completion system improves with every release. Believe me.\n"
    printf "  |\n"
    printf "  |    Versions v4.3+ have multibyte support built in.\n"
    printf "  |    So, if you are in a UTF-8 locale, that is for you.\n"
    printf "  |\n"
    printf "  |    Anyway, have fun using zsh. :-)\n"
    printf "  |\n\n"
fi #}}}

### build $ZRCS[]
zrcsource "zshrc.d/aliases"       ### setup aliases
### setup proper completion system for current zsh version
if zis_317 "atleast" ; then
    zrcsource "zshrc.d/compsys"
else
    zrcsource "zshrc.d/compctl"
fi
zrcsource "zshrc.d/misc"          ### other configuration
zrcsource "zshrc.d/modules"       ### load modules
zrcsource "zshrc.d/options"       ### setup zsh's options
zrcsource "zshrc.d/path"          ### set *path
zrcsource "zshrc.d/postrc"        ### executed after most of the other files
zrcsource "zshrc.d/styles"        ### zstyles for non-compsys systems
zrcsource "zshrc.d/vars"          ### setup variables
zrcsource "zshrc.d/zcleanup"      ### cleanups
zrcsource "zshrc.d/zfunct"        ### functions file
zrcsource "zshrc.d/zle"           ### setup zsh's line editor
zrcsource "zshrc.local"   '__local_settings;_do_not_care_if_it_is_missing__'

### re-sort $ZRCS[] based on #zdep lines.
zdepend

### compile 'zshrc' and 'zshrc.real' if needed.
if (( ZSHRC_COMPILE > 0 )) && zis_317 "atleast" ; then #{{{
    for rc in 'zshrc' 'zshrc.real' ; do
    if [[ -r "${ZRC_SOURCE_DIR}/${rc}" ]] ; then
        zrcneedcomp "${ZRC_SOURCE_DIR}/${rc}"
        needc=${?}
        if (( needc > 0)) ; then
            if (( needc == 1 )) ; then
                zprintf 1 'zshrc:   compiling %s.zwc\n' ${rc}
            elif (( needc == 2 )) ; then
                zprintf 1 'zshrc: recompiling %s.zwc\n' ${rc}
                rm -f "${ZRC_SOURCE_DIR}/${rc}.zwc"
            fi
            zcompile -URz "${ZRC_SOURCE_DIR}/${rc}"
        fi
    fi
    done
fi #}}}

### and finally try to source the files in $ZRCS[]
for rc in ${ZRCS} ; do #{{{
    if [[ -r ${rc} ]] ; then
        zprintf 1 "zshrc: loading %s\n" ${rc}

        ### zcompile support
        if (( ZSHRC_COMPILE > 0 )) ; then
            zrcneedcomp ${rc}
            needc=${?}
            if (( needc > 0)) ; then
                if (( needc == 1 )) ; then
                    zprintf 1 'zshrc:   compiling %s.zwc\n' ${rc}
                elif (( needc == 2 )) ; then
                    zprintf 1 'zshrc: recompiling %s.zwc\n' ${rc}
                    rm -f ${rc}.zwc
                fi
                zcompile -URz ${rc}
            fi
        fi
        ### End of zcompile support

        source ${rc}
    else
        zprintf 0 "zshrc: could not load %s\n" ${rc}
    fi
done #}}}
