#zdep zshrc.d/modules,zshrc.d/options,zshrc.d/aliases
### vim:ft=zsh:foldmethod=marker
###
### Z-Shell Line Editor Setup
###
### Frank Terbeck <ft@bewatermyfriend.org>
### Updated by:
### Lee Hinman <lee at writequit dot org>
###
### URI: <http://ft.bewatermyfriend.org/comp/zsh.html>
###

zis_31 "atleast" || function zle() { }

### key setup {{{

### first of all: emacs mode
###   yeah, i'm a vi user, but vi-modes of shells drive me nuts
bindkey -e

### }}}
### load optional widgets {{{
### edit-command-line bound to 'ESC e' {{{

zrcautoload edit-command-line && \
    zle -N edit-command-line

### }}}
### complete words from history, and force filename completion {{{
if zis_317 "atleast" ; then
    zle -C complete-history complete-word _generic
    zstyle ':completion:complete-history:*' completer _history
    zle -C complete-files complete-word _generic
    zstyle ':completion:complete-files:*' completer _files
fi
### }}}
### backward clear from cursor to the next '/' {{{
if zis_317 "atleast" ; then

    function backward-kill-to-slash() {
        local WORDCHARS="${WORDCHARS:s,/,} \\\'"

        [[ $BUFFER != */* ]] && return
        [[ $LBUFFER == [^/]##/ ]] && return

        zle backward-kill-word
    }

    zle -N backward-kill-to-slash
fi
### }}}
### predict-{on,off} {{{

zrcautoload predict-on && \
    zle -N predict-on  && \
    zle -N predict-off

### }}}
### exec_on_xclip (see http://bewatermyfriend.org/posts/2007/05-17.17-57-48-computer.html) {{{

zrcautoload exec_on_xclip && \
    zle -N exec_on_xclip

### }}}
### jump behind the Nth word on the cmdline. {{{
if zis_317 "atleast" ; then

    function jump_after_wordN() {
        setopt localoptions noksharrays extendedglob
        local words
        local -i i num=$1

        (( num == 0 )) && (( num = 10 ))
        words=(${(z)BUFFER})
        if (( ${#words} <= num )) ; then
            CURSOR=${#BUFFER}
        else
            if (( num == 1 )) ; then
                CURSOR=${#${words[${num}]}}
                return
            fi

            (( CURSOR = 1 ))
            (( i = 1 ))
            while [[ ${i} -le ${num} ]] ; do
                (( CURSOR += ${#${words[$(( i ))]}} ))
                (( i == num )) && break

                while [[ ${BUFFER[$(( CURSOR + 1 ))]} == [[:space:]] ]] ; do
                    (( CURSOR++ ))
                done
                (( ++i ))
            done
        fi
    }

    zle -N jump_after_wordN

    for i in {0..9} ; do
        eval "function jump_after_word${i} () { jump_after_wordN ${i} }"
        zle -N jump_after_word${i}
    done
fi
### }}}
### history-search-end, similar to history-beginning-search-{back,for}ward {{{

if zrcautoload history-search-end ; then
    zle -N history-beginning-search-backward-end history-search-end
    zle -N history-beginning-search-forward-end history-search-end
fi

### }}}
### }}}
### use a powerful accep-line replacement {{{

zis_317 "atleast" && zrcautoload accept-line && accept-line

### }}}
### special keys setup {{{
if zis_316 "atleast" ; then

    # zkbd is the ultra fool-proof special keys handling solution.
    # However, it requires interactive setup for each terminal type, at least
    # once. If ZRC_WANT_ZKBD is greater then zero, zkbd is used. If not,
    # we will consult $terminfo[] for the required information (and the current
    # version of it does work pretty well). Both versions are absolutely compatible
    # and can be interchanged in the scope of this configuration.
    ZRC_WANT_ZKBD=${ZRC_WANT_ZKBD:-0}
    if (( ZRC_WANT_ZKBD > 0 )) ; then
        ### zkbd code
        local termfile k
        function Printf_file() {
            [[ -f "$2" ]] && printf "$1" "$2" && return 0
            return 1
        }

        function zrc_printf_termfile() {
            Printf_file '%s' ~/.zkbd/${TERM}-${VENDOR}-${OSTYPE} && return 0
            Printf_file '%s' ~/.zkbd/${TERM}-${DISPLAY}          && return 0
            return 1
        }

        termfile=$(zrc_printf_termfile)
        if [[ -z "${termfile}" ]] ; then
            zrcautoload zkbd && zkbd
            termfile=$(zrc_printf_termfile)
        fi

        if [[ -f "${termfile}" ]] ; then
            zprintf 1 '  zle: loading %s\n' "${termfile}"
            source "${termfile}"
        else
            zprintf 0 'termfile (%s) not found. zkbd failed.\n' "${termfile}"
        fi
        unset termfile
        unfunction Printf_file zrc_printf_termfile
    else
        # if we don't want zkbd, we'll try to get the info from terminfo
        typeset -A key
        key[Home]=${terminfo[khome]}
        key[End]=${terminfo[kend]}
        key[Insert]=${terminfo[kich1]}
        key[Delete]=${terminfo[kdch1]}
        key[Up]=${terminfo[kcuu1]}
        key[Down]=${terminfo[kcud1]}
        key[Left]=${terminfo[kcub1]}
        key[Right]=${terminfo[kcuf1]}
        key[PageUp]=${terminfo[kpp]}
        key[PageDown]=${terminfo[knp]}

        # fix ^[O to ^[[, if our terminfo entries are flawed by
        # ncurses' application mode... *sigh*
        for k in ${(k)key} ; do
            [[ ${key[$k]} == $'\eO'* ]] && key[$k]=${key[$k]/O/[}
        done
    fi

    for k in ${(k)key} ; do
        key[Alt-${k}]='^['${key[$k]}
    done

    for k in {0..9} {a-z} {A-Z} ; do
        for i in Ctrl- Alt- ; do
            case ${i} in
            (Ctrl-)
                [[ ${k} == [A-Z] ]] && continue
                key[${i}${k}]='^'${k}
                ;;
            (Alt-)
                # This might not work everywhere. Oh well...
                key[${i}${k}]='^['${k}
                ;;
            esac
        done
    done

    key[Alt-Enter]='^[^M'

    unset k
fi
### }}}
### custom bindings {{{

zrcbindkey    Home          beginning-of-line
zrcbindkey    End           end-of-line
zrcbindkey    Insert        overwrite-mode
zrcbindkey    Delete        delete-char
zrcbindkey    Up            up-line-or-history
zrcbindkey    Down          down-line-or-history
zrcbindkey    Left          backward-char
zrcbindkey    Right         forward-char
zrcbindkey    Ctrl-x-p      history-search-backward
zrcbindkey    Ctrl-x-P      history-search-forward
zrcbindkey    Ctrl-x-k      backward-kill-line
zrcbindkey    Alt-y         _most_recent_file
zrcbindkey    Alt-Enter     self-insert-unmeta
zrcbindkey -W Alt-D         zap-to-char
zrcbindkey -W Alt-F         delete-to-char
zrcbindkey -W Alt-e         edit-command-line
zrcbindkey -W Ctrl-x-b      exec_on_xclip
zrcbindkey -W Ctrl-x-Ctrl-b exec_on_xclip
zrcbindkey -W Ctrl-x-Ctrl-z predict-on
zrcbindkey -W Ctrl-z        predict-off
zrcbindkey -W Ctrl-x-w      backward-kill-to-slash
zrcbindkey -W Ctrl-x-f      complete-files
zrcbindkey -W Ctrl-x-h      complete-history
zrcbindkey -W Ctrl-x-H      _complete_help
zrcbindkey -W Ctrl-x-D      _complete_debug
zrcbindkey -W PageUp        history-beginning-search-backward-end
zrcbindkey -W PageDown      history-beginning-search-forward-end

zrcbindkey -s Ctrl-x-s      '*.[ch]'

zis_317 "atleast" && \
    zrcbindkey -W -M menuselect Alt-Enter accept-and-menu-complete

for i in {0..9} ; do zrcbindkey -W Ctrl-x-${i} jump_after_word${i} ; done

### }}}
